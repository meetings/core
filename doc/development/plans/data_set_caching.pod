=head1 NAME

A plan how to cache data sets in Dicole.

=head1 TASK INFORMATION

=over 4

=item B<Date>

$Date: 2009-01-07 14:42:32 $

=item B<Revision>

$Revision: 1.4 $

=item B<Severity>

Normal

=item B<Priority>

P5

=item B<Risk factor>

2

=item B<Estimate>

When needed.

=item B<Status>

Waiting for need. Needs to be concidered.

=back

=head1 ABSTRACT

This document details a plan how sets of data will be cached in the future Dicole environment. Even though it is not yet implemented developers should be aware of its structure so they can plan their data structures so that they are easily cached with the framework.

=head1 FOREWORD / WHY

Dicole is a highly dynamic and highly personalized framework - this does not favor caching of pre-generated output. Underneath Dicole uses a non-traditional way of generating content which does not favor caching of pre-generated output of page parts. This leaves us with the next possible caching point: to cache stable sets of data which are generated from large or multiple queries and transmuted to a general or personalized form. With this caching framework we plan to ease the caching of data which is global, unique to one group, unique one user or unique to one user in one group.

=head1 BASICS

By data set we mean a chunk of data. This data will be stored in the database in the form generated by L<Storable> freeze. Being familiar with Storable is not essential but getting to know the easy to use class can make your life easier in the future. So go and read perldoc Storable.

Data can belong to 4 different categories:

=over 4
=item B<Global data>

Data which is shared among all users. For example full navigation tree, available security levels and default theme properties.

=item B<Personal data>

Data which is tied only to one user. For example personalized navigation tree, users collection of rights, personal summary box contents and other personal settings.

=item B<Group specific data>

Data which is is shared by all users of one group. For example group summary box contents and group tool configurations.

=item B<Group and user specific data>

Data which belongs to one user and affects one group. This data type should be used with care since the amount of data entries can rise to a high number.

=back

As a programmer you will be dealing with stored data by keywords. You choose what keywords you use - prefix them with your package name to avoid collisions. After you have selected a keyword you must specify what type of objects affect the data set for this keyword so the system can keep track of wether the data has changed. After this you should make sure that every object that affects your data informs the system correctly when it changes. When all this is done you can simply ask the system for some data and it will return with the data or tell you to generate and store it again. The data you get will always be current.

=head1 EXAMPLES

Here is a simple dataset definition:

datasets.ini:

 [dataset my_package_myset]
 OpenInteract2::MyObject = user

This will choose a data set with keyword my_package_myset. It's validity depends on one object: OpenInteract2::MyObject. When the keyword my_package_myset is queried for data with user id 42 the system checks when the data was generated and when a MyObject associated with a user id 42 has changed the last time. If the data was generated after the last change, then the data is valid. Nice! So how does the system know when MyObject with user id 42 has changed? Lets see this definition:

spops.ini:

 [myobject]
 class = OpenInteract2::MyObject
 isa = Dicole::DataSetUpdater

 (etc..)

 [myobject dataset_track]
 user = user_id

This will tell the MyObject that each time it is saved, updated or removed it should inform the system that MyObject with user id in field user_id has changed. So now our dataset behind the keyword my_package_myset can know if it should be generated again. Wasn't it all simple? So what do we get out from this? Lets take a look at a piece of code:

 my $objects = CTX->lookup_object('myobject')->fetch_group( {
     where => 'user_id = 42'
 } );
 my $tree = $self->make_a_tree_of_myobjects( $objects ); # takes a long time

On each request we fetch the objects which belong to user 42 and we build up a tree of those objects, which takes a long time. If none of the objects we get from the query has changed the tree remains the same so on each request we do the same job again and again :(. So instead we use our dataset like this:

 my $tree = DataSetCache->fetch('my_package_myset', 42);
 unless (defined $tree) {
    my $objects = CTX->lookup_object('myobject')->fetch_group( {
        where => 'user_id = 42'
    } );
    $tree = $self->make_a_tree_of_myobjects( $objects );
    DataSetCache->store('my_package_myset', $tree, 42);
 }

And that is it! Now we get the same data with a single database query for and unique key element and without the tree building. Hooray!

=head1 IMPLEMENTATION

Its so trivial I don't even bother to write about it x))). I'll do it when I have more time..

Key points:

=over 4

=item *

you can keep some of the data (like global data) duplicated in memory too if you wish..

=item *

essential update info can be fetched with select * from update_info where user in (0, uid) and group in (0, [user_gids]). might be wise to do in two runs to use indexes for both uid and gid..?

=item *

upon object update: 0,0 is always refreshed; uid, 0 is refreshed if user_id is specified; 0, gid is refreshed if group_id is specified; uid,gid is refreshed if both are provided.

=item *

you can disable needles updates from ini. for example global, user and group if only user+group is used.

=item *

data itself will be held in separate table accessible with large unique id's apart from other statically sized data (key, uid, gid, updated, expires).

=item *

more update info is fetched if needed so must be kept track of what is fetched and what is not.

=back

=head1 AUTHORS

Antti Vähäkotamäki, E<lt>antti@ionstream.fiE<gt>
